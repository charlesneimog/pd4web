#pragma once

#if !defined(__EMSCRIPTEN__)
#error "This module requires Emscripten."
#endif

// Standard C++ Libraries
#include <algorithm>
#include <format>
#include <iostream>
#include <sstream>
#include <mutex>
#include <condition_variable>
#include <tuple>
#include <fstream>
#include <iostream>

// Emscripten APIs
#include <emscripten.h>
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten/webaudio.h>
#include <emscripten/html5.h>

// Pure Data (libpd) Headers
#include <z_libpd.h>
#include <z_print_util.h>
#include <z_queued.h>

#include <g_canvas.h>
#include <m_imp.h>

// Local project headers
#include "config.h"

// External initialization function
extern void Pd4WebInitExternals(); // defined in externals.cpp (generated by pd4web compiler)

// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚            Pd4Web Lua Support       â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>

#include <pdlua.h>
#define NANOSVG_IMPLEMENTATION
#include <svg/nanosvg.h>
extern lua_State *__L();
extern void pdlua_setup();
}

// TODO: Remove
template<typename T>
struct Point {
    T x;
    T y;

    Point() : x(0), y(0) {}
    Point(T x_, T y_) : x(x_), y(y_) {}

    // soma
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }

    // subtraÃ§Ã£o
    Point operator-(const Point& other) const {
        return Point(x - other.x, y - other.y);
    }

    // multiplicaÃ§Ã£o por escalar
    Point operator*(T scalar) const {
        return Point(x * scalar, y * scalar);
    }

    // divisÃ£o por escalar
    Point operator/(T scalar) const {
        return Point(x / scalar, y / scalar);
    }
};


// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚            Graphics / GL Setup      â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
#ifdef PD4WEB_WEBGPU
#include <webgpu/webgpu.h>
#include <emscripten/html5_webgpu.h>
#else
#include <GLES3/gl3.h>
#define NANOVG_GLES3_IMPLEMENTATION
#include <nanovg.h>
#include <nanovg_gl.h>
#include <nanovg_gl_utils.h>
#endif

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ User Data Struct â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
enum Pd4WebSenderType { 
    BANG = 0, 
    FLOAT, 
    SYMBOL, 
    LIST, 
    MESSAGE,
    MOUSE_EVENT,
    KEY_EVENT,
    TOUCH_EVENT
};

// Thread-safe atom structure for passing list/message data
struct Pd4WebAtom {
    enum Type { FLOAT_TYPE, SYMBOL_TYPE };
    Type type;
    float f_value;
    std::string s_value;
    
    Pd4WebAtom() : type(FLOAT_TYPE), f_value(0.0f) {}
    explicit Pd4WebAtom(float f) : type(FLOAT_TYPE), f_value(f) {}
    explicit Pd4WebAtom(const std::string& s) : type(SYMBOL_TYPE), s_value(s) {}
};

// Event data structures
struct MouseEventData {
    int x;
    int y;
    int button;
    bool shift;
    bool ctrl;
    bool alt;
    enum EventType { MOUSE_DOWN, MOUSE_UP, MOUSE_MOVE } event_type;
};

struct KeyEventData {
    std::string key;
    int keyCode;
    bool shift;
    bool ctrl;
    bool alt;
    enum EventType { KEY_DOWN, KEY_UP } event_type;
};

struct TouchEventData {
    int x;
    int y;
    int identifier;
    enum EventType { TOUCH_START, TOUCH_END, TOUCH_MOVE, TOUCH_CANCEL } event_type;
};

struct Pd4WebUserData {
    class Pd4Web *pd4web;
    t_pdinstance *libpd;

    bool redraw = true;
    bool needsSwap = false;
    int fbWidth;
    int fbHeight;

    // Sound state
    bool soundInit;
    bool soundSuspended;
    std::string soundToggleSel;

    // last frame
    double lastFrame;

    // Canvas selection
    std::string canvasSel;
    std::string canvasId;

    // Audio processing synchronization
    std::mutex mtx;
    std::condition_variable cv;
    bool drawing = false;
    bool processing = false;

    // Mouse state
    bool mousedown;
    bool doit;
    int xpos;
    int ypos;
    int canvas_width;
    int canvas_height;
    int canvas_marginx;
    int canvas_marginy;
    float devicePixelRatio;
    t_gobj *obj;
    t_canvas *canvas;

    // Keyboard input
    std::string key;

    // Rendering optimization
    bool first_frame = true;
    int font_handler = 0;
    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
    bool contextReady = false;
    bool openNumberKeyboard = false;

    NVGcontext *vg;
    NVGLUframebuffer *fb = nullptr;
    NVGLUframebuffer *mainFBO = nullptr;
};

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PdLua Graphics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

struct PdLuaObjGuiLayer {
    bool dirty = false;
    bool drawing = false;

    // pdlua
    std::string layer_id;
    std::vector<GuiCommand> gui_commands;
    int size;

    // framebuffer
    int objx;
    int objy;
    int objw;
    int objh;
#ifdef PD4WEB_WEBGPU
#else
    NVGLUframebuffer *fb = nullptr;
#endif
    float last_zoom = 0; // Track last zoom to detect changes
    int fb_width = 0;
    int fb_height = 0;
};

using PdLuaObjLayers = std::map<int, PdLuaObjGuiLayer>;
using PdLuaObjsGui = std::unordered_map<std::string, PdLuaObjLayers>;
using PdInstanceGui = std::unordered_map<t_pdinstance *, PdLuaObjsGui>;

// â”€â”€â”€â”€â”€â”€â”€ Senders and Receivers â”€â”€â”€â”€
// Thread-safe sender structure with owned string data
struct Pd4WebSender {
    std::string receiver;  // Owned string, safe across threads
    Pd4WebSenderType type;
    std::string selector;  // For MESSAGE type
    
    // Type-specific data (owned, not pointers)
    float f_value;
    std::string s_value;
    std::vector<Pd4WebAtom> list_data;  // For LIST and MESSAGE types
    
    // Event data
    MouseEventData mouse_data;
    KeyEventData key_data;
    TouchEventData touch_data;
    
    Pd4WebSender() : type(BANG), f_value(0.0f) {}
    
    // Factory methods for type-safe construction
    static Pd4WebSender* CreateBang(const std::string& recv) {
        auto* sender = new Pd4WebSender();
        sender->type = BANG;
        sender->receiver = recv;
        return sender;
    }
    
    static Pd4WebSender* CreateFloat(const std::string& recv, float value) {
        auto* sender = new Pd4WebSender();
        sender->type = FLOAT;
        sender->receiver = recv;
        sender->f_value = value;
        return sender;
    }
    
    static Pd4WebSender* CreateSymbol(const std::string& recv, const std::string& sym) {
        auto* sender = new Pd4WebSender();
        sender->type = SYMBOL;
        sender->receiver = recv;
        sender->s_value = sym;
        return sender;
    }
    
    static Pd4WebSender* CreateList(const std::string& recv, const std::vector<Pd4WebAtom>& atoms) {
        auto* sender = new Pd4WebSender();
        sender->type = LIST;
        sender->receiver = recv;
        sender->list_data = atoms;
        return sender;
    }
    
    static Pd4WebSender* CreateMessage(const std::string& recv, const std::string& sel, 
                                       const std::vector<Pd4WebAtom>& atoms) {
        auto* sender = new Pd4WebSender();
        sender->type = MESSAGE;
        sender->receiver = recv;
        sender->selector = sel;
        sender->list_data = atoms;
        return sender;
    }
    
    static Pd4WebSender* CreateMouseEvent(const MouseEventData& data) {
        auto* sender = new Pd4WebSender();
        sender->type = MOUSE_EVENT;
        sender->mouse_data = data;
        return sender;
    }
    
    static Pd4WebSender* CreateKeyEvent(const KeyEventData& data) {
        auto* sender = new Pd4WebSender();
        sender->type = KEY_EVENT;
        sender->key_data = data;
        return sender;
    }
    
    static Pd4WebSender* CreateTouchEvent(const TouchEventData& data) {
        auto* sender = new Pd4WebSender();
        sender->type = TOUCH_EVENT;
        sender->touch_data = data;
        return sender;
    }
};

static std::unordered_map<t_pdinstance *, std::unordered_map<std::string, emscripten::val>>
    ReceiverListeners;

using ReceiverMap = std::unordered_map<std::string, emscripten::val>;
using Pd4WebReceiverListeners = std::unordered_map<t_pdinstance *, ReceiverMap>;

static Pd4WebReceiverListeners BangReceiverListeners;
static Pd4WebReceiverListeners FloatReceiverListeners;
static Pd4WebReceiverListeners SymbolReceiverListeners;
static Pd4WebReceiverListeners ListReceiverListeners;
static Pd4WebReceiverListeners MessageReceiverListeners;

// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚             Main Class              â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
class Pd4Web {
  public:
    ~Pd4Web() {
        for (auto symbol : m_BindSymbols) {
            libpd_unbind(symbol);
        }
        libpd_free_instance(m_PdInstance);
    }

    // Main
    void Init();
    void ToggleAudio();
    void OpenPatchJS(const std::string &patchPath, emscripten::val options);

    // Send messages
    void SendFloat(std::string receiver, float value);
    void SendSymbol(std::string receiver, std::string symbol);
    void SendBang(std::string receiver);
    void SendList(std::string receiver, emscripten::val list);
    void SendMessage(std::string receiver, std::string msg, emscripten::val list);

    // Bind callbacks
    void OnBangReceived(std::string receiver, emscripten::val callback);
    void OnFloatReceived(std::string receiver, emscripten::val callback);
    void OnSymbolReceived(std::string receiver, emscripten::val callback);
    void OnListReceived(std::string receiver, emscripten::val callback);
    void OnMessageReceived(std::string r, emscripten::val callback);

    // Mouse position
    void GetLastMousePosition(int *x, int *y);
    void SetLastMousePosition(int x, int y);

    // File Transfering
    void SendFile(emscripten::val jsArrayBuffer, std::string filename);

    // WebAudio
    EMSCRIPTEN_WEBAUDIO_T GetWebAudioContext();
    void SetWebAudioContext(EMSCRIPTEN_WEBAUDIO_T context);
    void SetSampleRate(float sampleRate);
    float GetSampleRate();

    // Get
    std::string GetPatchPath();
    std::string GetCanvasId();
    std::string GetSoundToggleId();
    std::string GetProjectName();
    int GetChannelCountIn();
    int GetChannelCountOut();
    float GetPatchZoom();
    int GetFps();
    std::string GetBGColor();
    std::string GetFGColor();

    bool RenderGui();
    bool UseMidi();
    std::vector<Pd4WebSender *> &getToSendData() {
        return m_ToSendData;
    }

    std::mutex m_ToSendMutex; // ðŸ”’ proteÃ§Ã£o

  private:
    void OpenPatch(std::string patchPath, std::string patchCanvasId, std::string soundToggleId);
    void StartMidi();

    std::vector<void *> m_BindSymbols;
    std::vector<Pd4WebSender *> m_ToSendData;

    // Theme
    std::string m_BgColor;
    std::string m_FgColor;

    // User data
    std::shared_ptr<Pd4WebUserData> m_UserData;

    bool m_Pd4WebAudioWorkletInit = false;
    bool m_AudioSuspended = false;

    t_pdinstance *m_PdInstance = nullptr;
    EMSCRIPTEN_WEBAUDIO_T m_AudioContext;

    // Mouse
    int m_LastMouseX = 0;
    int m_LastMouseY = 0;

    // User Configurations
    std::string m_PatchPath = "";
    std::string m_CanvasId = "";
    std::string m_SoundToggleId = "";
    std::string m_ProjectName = "";

    int m_ChannelCountIn = 0;
    int m_ChannelCountOut = 0;
    float m_SampleRate = 48000.0f;
    bool m_UseMidi;

    float m_PatchZoom = 1;
    bool m_RenderGui = true;
    int m_Fps = 0;
};

// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚           Function Prototypes       â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
void FakeLoop(void *userData);
void Loop(void *userData);
void GetGLContext(Pd4WebUserData *ud);
void RenderPatchComments(Pd4WebUserData *ud);
void ProcessMouseEvent(Pd4WebUserData *ud, const MouseEventData& data);
void ProcessTouchEvent(Pd4WebUserData *ud, const TouchEventData& data);
void ProcessKeyEvent(Pd4WebUserData *ud, const KeyEventData& data); 

// â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
// â”‚  Bind C++ functions to JavaScript   â”‚
// â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
void SetupMIDI();
void OnMIDISuccess(emscripten::val midiAccess);
void OnMIDIFailed(emscripten::val error);
void OnMIDIInMessage(emscripten::val event);
void OnMIDIOutMessage(emscripten::val event);

EMSCRIPTEN_BINDINGS(Pd4WebModule) {
    function("_onMIDISuccess", &OnMIDISuccess);
    function("_onMIDIFailed", &OnMIDIFailed);
    function("_onMIDIInMessage", &OnMIDIInMessage);
    function("_onMIDIOutMessage", &OnMIDIOutMessage);

    emscripten::class_<Pd4Web>("Pd4Web")
        .constructor<>() // Default constructor
        .function("init", &Pd4Web::Init)
        .function("openPatch", &Pd4Web::OpenPatchJS)
        .function("toggleAudio", &Pd4Web::ToggleAudio)

        // send file
        .function("sendFile", &Pd4Web::SendFile)

        // senders
        .function("sendBang", &Pd4Web::SendBang)
        .function("sendFloat", &Pd4Web::SendFloat)
        .function("sendSymbol", &Pd4Web::SendSymbol)
        .function("sendList", &Pd4Web::SendList)
        .function("sendMessage", &Pd4Web::SendMessage)

        // bind and unbind receivers
        .function("onBangReceived", &Pd4Web::OnBangReceived)
        .function("onFloatReceived", &Pd4Web::OnFloatReceived)
        .function("onSymbolReceived", &Pd4Web::OnSymbolReceived)
        .function("onListReceived", &Pd4Web::OnListReceived)
        .function("onMessageReceived", &Pd4Web::OnMessageReceived);
}
