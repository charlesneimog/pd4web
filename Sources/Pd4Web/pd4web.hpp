#pragma once

#if !defined(__EMSCRIPTEN__)
#error "This module requires Emscripten."
#endif

// Standard C++ Libraries
#include <algorithm>
#include <format>
#include <iostream>
#include <sstream>
#include <mutex>
#include <condition_variable>
#include <tuple>

// Emscripten APIs
#include <emscripten.h>
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten/webaudio.h>

// Pure Data (libpd) Headers
#include <z_libpd.h>
#include <z_print_util.h>
#include <z_queued.h>
#include <g_canvas.h>

// Local project headers
#include "config.h"

// External initialization function
extern void Pd4WebInitExternals(); // defined in externals.cpp (generated by pd4web compiler)

// ╭─────────────────────────────────────╮
// │            Pd4Web Lua Support       │
// ╰─────────────────────────────────────╯
#if PD4WEB_LUA
extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include <pdlua.h>

extern lua_State *__L();
extern int pd4weblua_draw();
extern void pdlua_setup();
}
#endif

// ╭─────────────────────────────────────╮
// │            Graphics / GL Setup      │
// ╰─────────────────────────────────────╯
#ifdef PD4WEB_WEBGPU
#include <webgpu/webgpu.h>
#include <emscripten/html5_webgpu.h>
#else
#include <GLES3/gl3.h>
#define NANOVG_GLES3_IMPLEMENTATION
#include <nanovg.h>
#include <nanovg_gl.h>
#include <nanovg_gl_utils.h>
#endif

// ────────── User Data Struct ──────────
enum Pd4WebSenderType { BANG = 0, FLOAT, SYMBOL, LIST, MESSAGE };

struct Pd4WebUserData {
    class Pd4Web *pd4web;
    t_pdinstance *libpd;

    bool redraw = true;

    // Sound state
    bool soundInit;
    bool soundSuspended;
    std::string soundToggleSel;

    // Canvas selection
    std::string canvasSel;

    // Audio processing synchronization
    std::mutex mtx;
    std::condition_variable cv;
    bool drawing = false;
    bool processing = false;

    // Mouse state
    bool mousedown;
    bool doit;
    int xpos;
    int ypos;
    int canvas_width;
    int canvas_height;
    float devicePixelRatio;
    t_gobj *obj;
    t_canvas *canvas;

    // Keyboard input
    std::string key;

    // Rendering optimization
    bool first_frame = true;
    int font_handler = 0;
    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
    bool contextReady = false;

#ifdef PD4WEB_WEBGPU
    WGPUDevice *vg;
#else
    NVGcontext *vg;
    NVGLUframebuffer *invalidFBO;
    NVGLUframebuffer *fb = nullptr;
#endif
};

// ─────────── PdLua Graphics ───────────

struct PdLuaObjGuiLayer {
    bool dirty = false;
    bool drawing = false;

    // pdlua
    std::string layer_id;
    std::vector<GuiCommand> gui_commands;
    int size;

    // framebuffer
    int objx;
    int objy;
    int objw;
    int objh;
#ifdef PD4WEB_WEBGPU
#else
    NVGLUframebuffer *fb = nullptr;
#endif
    float last_zoom = 0; // Track last zoom to detect changes
};
using PdLuaObjLayers = std::unordered_map<int, PdLuaObjGuiLayer>;
using PdLuaObjsGui = std::unordered_map<std::string, PdLuaObjLayers>;
using PdInstanceGui = std::unordered_map<t_pdinstance *, PdLuaObjsGui>;

// ─────── Senders and Receivers ────
struct Pd4WebSender {
    const char *receiver;
    Pd4WebSenderType type;
    const char *sel;

    float f;
    const char *m;
    emscripten::val l;
};

static std::unordered_map<t_pdinstance *, std::unordered_map<std::string, emscripten::val>>
    ReceiverListeners;

using ReceiverMap = std::unordered_map<std::string, emscripten::val>;
using Pd4WebReceiverListeners = std::unordered_map<t_pdinstance *, ReceiverMap>;

static Pd4WebReceiverListeners BangReceiverListeners;
static Pd4WebReceiverListeners FloatReceiverListeners;
static Pd4WebReceiverListeners SymbolReceiverListeners;
static Pd4WebReceiverListeners ListReceiverListeners;

// ╭─────────────────────────────────────╮
// │             Main Class              │
// ╰─────────────────────────────────────╯
class Pd4Web {
  public:
    ~Pd4Web() {
        for (auto s : m_bindSymbols) {
            libpd_unbind(s);
        }
        libpd_free_instance(m_NewPdInstance);
    }

    // Main
    void init();
    void suspendAudio();
    void openPatchJS(const std::string &patchPath, emscripten::val options);

    // send Messages
    void sendFloat(std::string r, float f);
    void sendSymbol(std::string r, std::string s);
    void sendBang(std::string r);
    void sendList(std::string r, emscripten::val a);
    void sendMessage(std::string r, std::string s, emscripten::val a);

    // bind
    void onBangReceived(std::string r, emscripten::val func);
    void onFloatReceived(std::string r, emscripten::val func);
    void onSymbolReceived(std::string r, emscripten::val func);
    void onListReceived(std::string r, emscripten::val func);

    // Mouse Position
    void getLastMousePosition(int *x, int *y);
    void setLastMousePosition(int x, int y);

    // WebAudioContext
    EMSCRIPTEN_WEBAUDIO_T getWebAudioContext();
    void setWebAudioContext(EMSCRIPTEN_WEBAUDIO_T ctx);

  private:
    void openPatch(std::string PatchPath, std::string PatchCanvaId, std::string soundToggleId);
    void startMidi();
    std::vector<void *> m_bindSymbols;

    // Theme
    bool m_ThemeDefined = false;
    bool m_DarkTheme = false;

    // This make the class destructor free this memory
    std::unique_ptr<Pd4WebUserData> m_SoundBtn;
    std::unique_ptr<Pd4WebUserData> m_EventCtx;
    std::unique_ptr<Pd4WebUserData> m_GuiLoopCtx;

    std::string canvasId;
    bool m_Pd4WebInit = false;
    bool m_PdInit = false;
    bool m_audioSuspended = false;

    t_pdinstance *m_NewPdInstance;
    EMSCRIPTEN_WEBAUDIO_T m_Context;

    // mouse
    int m_LastMouseX;
    int m_LastMouseY;
};

// ╭─────────────────────────────────────╮
// │           Function Prototypes       │
// ╰─────────────────────────────────────╯
void loop(void *userData);
void getGlCtx(Pd4WebUserData *ud);

// ╭─────────────────────────────────────╮
// │  Bind C++ functions to JavaScript   │
// ╰─────────────────────────────────────╯
void onMIDISuccess(emscripten::val midiAccess);
void onMIDIFailed(emscripten::val error);
void onMIDIInMessage(emscripten::val event);
void onMIDIOutMessage(emscripten::val event);

EMSCRIPTEN_BINDINGS(Pd4WebModule) {
    function("onMIDISuccess", &onMIDISuccess);
    function("onMIDIFailed", &onMIDIFailed);
    function("onMIDIInMessage", &onMIDIInMessage);
    function("onMIDIOutMessage", &onMIDIOutMessage);

    emscripten::class_<Pd4Web>("Pd4Web")
        .constructor<>() // Default constructor
        .function("openPatch", &Pd4Web::openPatchJS)
        .function("suspendAudio", &Pd4Web::suspendAudio)

        // senders
        .function("sendBang", &Pd4Web::sendBang)
        .function("sendFloat", &Pd4Web::sendFloat)
        .function("sendSymbol", &Pd4Web::sendSymbol)
        .function("sendList", &Pd4Web::sendList)
        .function("sendMessage", &Pd4Web::sendMessage)

        // bind and unbind receivers
        .function("onBangReceived", &Pd4Web::onBangReceived)
        .function("onFloatReceived", &Pd4Web::onFloatReceived)
        .function("onSymbolReceived", &Pd4Web::onSymbolReceived)
        .function("onListReceived", &Pd4Web::onListReceived);
}
