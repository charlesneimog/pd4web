#pragma once

#if !defined(__EMSCRIPTEN__)
#error "This module requires Emscripten."
#endif

// Standard C++ Libraries
#include <algorithm>
#include <format>
#include <iostream>
#include <sstream>
#include <mutex>
#include <condition_variable>
#include <tuple>
#include <fstream>
#include <iostream>

// Emscripten APIs
#include <emscripten.h>
#include <emscripten/bind.h>
#include <emscripten/val.h>
#include <emscripten/webaudio.h>

// Pure Data (libpd) Headers
#include <z_libpd.h>
#include <z_print_util.h>
#include <z_queued.h>

#include <g_canvas.h>
#include <m_imp.h>

// Local project headers
#include "config.h"

// External initialization function
extern void Pd4WebInitExternals(); // defined in externals.cpp (generated by pd4web compiler)

// ╭─────────────────────────────────────╮
// │            Pd4Web Lua Support       │
// ╰─────────────────────────────────────╯
#if PD4WEB_LUA
extern "C" {
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include <pdlua.h>

extern lua_State *__L();
extern int pd4weblua_draw();
extern void pdlua_setup();
}
#endif

// ╭─────────────────────────────────────╮
// │            Graphics / GL Setup      │
// ╰─────────────────────────────────────╯
#ifdef PD4WEB_WEBGPU
#include <webgpu/webgpu.h>
#include <emscripten/html5_webgpu.h>
#else
#include <GLES3/gl3.h>
#define NANOVG_GLES3_IMPLEMENTATION
#include <nanovg.h>
#include <nanovg_gl.h>
#include <nanovg_gl_utils.h>
#endif

// ────────── User Data Struct ──────────
enum Pd4WebSenderType { BANG = 0, FLOAT, SYMBOL, LIST, MESSAGE };

struct Pd4WebUserData {
    class Pd4Web *pd4web;
    t_pdinstance *libpd;

    bool redraw = true;
    bool needsSwap = false;
    int fbWidth;
    int fbHeight;

    // Sound state
    bool soundInit;
    bool soundSuspended;
    std::string soundToggleSel;

    // last frame
    double lastFrame;

    // Canvas selection
    std::string canvasSel;

    // Audio processing synchronization
    std::mutex mtx;
    std::condition_variable cv;
    bool drawing = false;
    bool processing = false;

    // Mouse state
    bool mousedown;
    bool doit;
    int xpos;
    int ypos;
    int canvas_width;
    int canvas_height;
    int canvas_marginx;
    int canvas_marginy;
    float devicePixelRatio;
    t_gobj *obj;
    t_canvas *canvas;

    // Keyboard input
    std::string key;

    // Rendering optimization
    bool first_frame = true;
    int font_handler = 0;
    EMSCRIPTEN_WEBGL_CONTEXT_HANDLE ctx;
    bool contextReady = false;

    NVGcontext *vg;
    NVGLUframebuffer *fb = nullptr;
    NVGLUframebuffer *mainFBO = nullptr;
};

// ─────────── PdLua Graphics ───────────

struct PdLuaObjGuiLayer {
    bool dirty = false;
    bool drawing = false;

    // pdlua
    std::string layer_id;
    std::vector<GuiCommand> gui_commands;
    int size;

    // framebuffer
    int objx;
    int objy;
    int objw;
    int objh;
#ifdef PD4WEB_WEBGPU
#else
    NVGLUframebuffer *fb = nullptr;
#endif
    float last_zoom = 0; // Track last zoom to detect changes
    int fb_width = 0;
    int fb_height = 0;
};

using PdLuaObjLayers = std::map<int, PdLuaObjGuiLayer>;
using PdLuaObjsGui = std::unordered_map<std::string, PdLuaObjLayers>;
using PdInstanceGui = std::unordered_map<t_pdinstance *, PdLuaObjsGui>;

// ─────── Senders and Receivers ────
struct Pd4WebSender {
    const char *receiver;
    Pd4WebSenderType type;
    const char *sel;

    float f;
    const char *m;
    emscripten::val l;
};

static std::unordered_map<t_pdinstance *, std::unordered_map<std::string, emscripten::val>>
    ReceiverListeners;

using ReceiverMap = std::unordered_map<std::string, emscripten::val>;
using Pd4WebReceiverListeners = std::unordered_map<t_pdinstance *, ReceiverMap>;

static Pd4WebReceiverListeners BangReceiverListeners;
static Pd4WebReceiverListeners FloatReceiverListeners;
static Pd4WebReceiverListeners SymbolReceiverListeners;
static Pd4WebReceiverListeners ListReceiverListeners;

// ╭─────────────────────────────────────╮
// │             Main Class              │
// ╰─────────────────────────────────────╯
class Pd4Web {
  public:
    ~Pd4Web() {
        for (auto symbol : m_BindSymbols) {
            libpd_unbind(symbol);
        }
        libpd_free_instance(m_PdInstance);
    }

    // Main
    void Init();
    void ToggleAudio();
    void OpenPatchJS(const std::string &patchPath, emscripten::val options);

    // Send messages
    void SendFloat(std::string receiver, float value);
    void SendSymbol(std::string receiver, std::string symbol);
    void SendBang(std::string receiver);
    void SendList(std::string receiver, emscripten::val list);
    void SendMessage(std::string receiver, std::string msg, emscripten::val list);

    // Bind callbacks
    void OnBangReceived(std::string receiver, emscripten::val callback);
    void OnFloatReceived(std::string receiver, emscripten::val callback);
    void OnSymbolReceived(std::string receiver, emscripten::val callback);
    void OnListReceived(std::string receiver, emscripten::val callback);

    // Mouse position
    void GetLastMousePosition(int *x, int *y);
    void SetLastMousePosition(int x, int y);

    // File Transfering
    void SendFile(emscripten::val jsArrayBuffer, std::string filename);

    // WebAudio
    EMSCRIPTEN_WEBAUDIO_T GetWebAudioContext();
    void SetWebAudioContext(EMSCRIPTEN_WEBAUDIO_T context);
    void SetSampleRate(float sampleRate);
    float GetSampleRate();

    // Get
    std::string GetPatchPath();
    std::string GetCanvasId();
    std::string GetSoundToggleId();
    std::string GetProjectName();
    int GetChannelCountIn();
    int GetChannelCountOut();
    float GetPatchZoom();
    int GetFps();
    std::string GetBGColor();
    std::string GetFGColor();

    bool RenderGui();
    bool UseMidi();

  private:
    void OpenPatch(std::string patchPath, std::string patchCanvasId, std::string soundToggleId);
    void StartMidi();

    std::vector<void *> m_BindSymbols;

    // Theme
    std::string m_BgColor;
    std::string m_FgColor;

    // User data
    std::shared_ptr<Pd4WebUserData> m_UserData;

    bool m_Pd4WebAudioWorkletInit = false;
    bool m_AudioSuspended = false;

    t_pdinstance *m_PdInstance = nullptr;
    EMSCRIPTEN_WEBAUDIO_T m_AudioContext;

    // Mouse
    int m_LastMouseX = 0;
    int m_LastMouseY = 0;

    // User Configurations
    std::string m_PatchPath = "";
    std::string m_CanvasId = "";
    std::string m_SoundToggleId = "";
    std::string m_ProjectName = "";

    int m_ChannelCountIn = 0;
    int m_ChannelCountOut = 0;
    float m_SampleRate = 48000.0f;
    bool m_UseMidi;

    float m_PatchZoom = 1;
    bool m_RenderGui = true;
    int m_Fps = 0;
};

// ╭─────────────────────────────────────╮
// │           Function Prototypes       │
// ╰─────────────────────────────────────╯
void Loop(void *userData);
void GetGLContext(Pd4WebUserData *ud);
void RenderPatchComments(Pd4WebUserData *ud);

// ╭─────────────────────────────────────╮
// │  Bind C++ functions to JavaScript   │
// ╰─────────────────────────────────────╯
void SetupMIDI();
void OnMIDISuccess(emscripten::val midiAccess);
void OnMIDIFailed(emscripten::val error);
void OnMIDIInMessage(emscripten::val event);
void OnMIDIOutMessage(emscripten::val event);

EMSCRIPTEN_BINDINGS(Pd4WebModule) {
    function("_onMIDISuccess", &OnMIDISuccess);
    function("_onMIDIFailed", &OnMIDIFailed);
    function("_onMIDIInMessage", &OnMIDIInMessage);
    function("_onMIDIOutMessage", &OnMIDIOutMessage);

    emscripten::class_<Pd4Web>("Pd4Web")
        .constructor<>() // Default constructor
        .function("openPatch", &Pd4Web::OpenPatchJS)
        .function("toggleAudio", &Pd4Web::ToggleAudio)

        // send file
        .function("sendFile", &Pd4Web::SendFile)

        // senders
        .function("sendBang", &Pd4Web::SendBang)
        .function("sendFloat", &Pd4Web::SendFloat)
        .function("sendSymbol", &Pd4Web::SendSymbol)
        .function("sendList", &Pd4Web::SendList)
        .function("sendMessage", &Pd4Web::SendMessage)

        // bind and unbind receivers
        .function("onBangReceived", &Pd4Web::OnBangReceived)
        .function("onFloatReceived", &Pd4Web::OnFloatReceived)
        .function("onSymbolReceived", &Pd4Web::OnSymbolReceived)
        .function("onListReceived", &Pd4Web::OnListReceived);
}
